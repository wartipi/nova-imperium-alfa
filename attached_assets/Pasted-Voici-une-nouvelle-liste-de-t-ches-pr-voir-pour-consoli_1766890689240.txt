Voici une nouvelle liste de tâches à prévoir pour consolider la phase 1 et préparer la suite, structurée comme la dernière fois. Pour chaque point, je précise s’il s’agit d’un problème déjà identifié précédemment ou d’une observation nouvelle apparue lors des relectures récentes.

| N°    | Composant / Domaine                             | À corriger ou à réaliser                                                                                                                                                                     | Observations (déjà identifié / nouveau)                        | Instructions techniques                                                                                                                                                                                                                                                                                                                                                                                                               |
| ----- | ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | **Authentification et autorisations**           | Actuellement, toutes les routes acceptent des identifiants en clair. Aucun contrôle d’accès n’est implémenté.                                                                                | **Déjà identifié** – toujours non traité.                      | Introduire un middleware d’authentification (JWT ou sessions) qui vérifie l’identité du joueur sur chaque requête. Attacher les informations de l’utilisateur à `req.user`. Dans chaque route, utiliser `req.user.id` pour vérifier que le joueur est bien autorisé à créer/modifier les entités (par ex. un contrat pour une armée qu’il possède).                                                                                   |
| **2** | **Transactions généralisées**                   | Certaines méthodes qui modifient plusieurs tables en même temps (progression de cartographie, création de cartes, acceptation d’offres, etc.) ne sont pas encapsulées dans des transactions. | **Nouveau** (mis en lumière lors des dernières relectures)     | Rechercher toutes les fonctions qui effectuent plusieurs opérations d’écriture (plusieurs `await db.update()` ou `db.insert()`). Enrober ces appels dans `db.transaction(async tx => { ... })`. Veiller à utiliser `tx` pour toutes les opérations à l’intérieur, afin de garantir l’atomicité en cas d’erreur.                                                                                                                       |
| **3** | **Recherche de régions (`findRegionAt`)**       | Même si un filtre SQL par rectangle est utilisé, la distance exacte est encore calculée en mémoire pour tous les résultats du rectangle.                                                     | **Déjà identifié** – toujours non traité.                      | Si possible, exploiter une extension géospatiale (par ex. `cube`/`earthdistance` ou un champ `POINT`) pour calculer la distance directement en SQL : `WHERE point <@> point_ref <= radius`. À défaut, réduire encore la taille du rectangle (limiter le nombre de résultats) ou créer un index géographique.                                                                                                                          |
| **4** | **Filtrage des salles de troc par participant** | `getTradeRoomsForPlayer` récupère toujours toutes les salles actives puis filtre en mémoire celles où figure le joueur.                                                                      | **Déjà identifié** – semble toujours partiellement non traité. | Stocker la liste des participants dans une colonne JSONB `participants` ou, mieux, créer une table `trade_room_participants (room_id, player_id)`. Ajouter un index GIN sur la colonne JSONB ou une clé primaire sur la table de jointure. Modifer `getTradeRoomsForPlayer` pour utiliser `WHERE participants @> ARRAY[playerId]::jsonb` ou une jointure SQL au lieu de filtrer en mémoire.                                           |
| **5** | **Validation des entrées et tests**             | Toutes les routes ne valident pas leurs payloads avec Zod et il n’existe pas de tests automatisés pour vérifier les scénarios clés.                                                          | **Déjà identifié** – toujours non traité.                      | Créer un schéma Zod pour chaque endpoint (contrats, cartes, offres, projets, etc.) et intégrer la validation dans la route via un middleware (ex. `validateBody(schema)`). Ajouter des tests d’intégration (Jest/Vitest) pour les cas suivants : création d’une armée, proposition et acceptation de contrats, démarrage et progression d’un projet de cartographie, publication d’un événement public, échange de ressources/objets. |
| **6** | **Indexation et performance**                   | Les requêtes filtrant sur des champs JSONB ou des coordonnées peuvent devenir lentes sans index appropriés.                                                                                  | **Nouveau**                                                    | Pour les colonnes JSONB utilisées avec `@>` (participants, participatingArmies), ajouter un index GIN. Pour les colonnes `pos_x`/`pos_y` créées pour la localisation, créer un index B-tree. Vérifier que les jointures fréquentes (ex. armées ↔ contrats, campagnes ↔ armées) sont bien indexées.                                                                                                                                    |
| **7** | **Modularité et documentation**                 | La logique métier se mélange parfois avec les opérations SQL, ce qui complique la lecture et la maintenance.                                                                                 | **Nouveau**                                                    | Extraire les requêtes complexes dans des méthodes dédiées ou des repositories, afin de séparer la logique de l’API de l’accès aux données. Mettre à jour la documentation (README ou docs internes) pour décrire les nouvelles tables, endpoints et comportements.                                                                                                                                                                    |

Ces tâches permettront de stabiliser et d’optimiser votre backend avant d’envisager de nouvelles fonctionnalités.
