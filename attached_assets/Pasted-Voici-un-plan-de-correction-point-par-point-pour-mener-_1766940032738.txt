Voici un plan de correction point par point pour mener Ã  bien les ajustements restants dans la branche **NIâ€‘architecturetest9.0â€‘agent3**. Chaque tÃ¢che est dÃ©crite avec des instructions techniques claires, et je prÃ©cise si elle rÃ©sulte dâ€™un problÃ¨me dÃ©jÃ  signalÃ© ou dâ€™une observation plus rÃ©cente.

---

## 1. Authentification et autorisations (dÃ©jÃ  identifiÃ©)

### Constat

Les routes acceptent encore des identifiants en clair, sans authentification ni contrÃ´le dâ€™accÃ¨s. Un module `auth.ts` existe (JWT, middlewares `requireAuth`, `requireRole`, etc.), mais il nâ€™est pas appliquÃ© partout.

### Instructions

1. **Installer la dÃ©pendance JWT** si nÃ©cessaire (`jsonwebtoken` cÃ´tÃ© serveur).
2. **Ajouter un middleware global**Â :

   ```ts
   // server/middleware/auth.ts (dÃ©jÃ  prÃ©sent, Ã  Ã©tendre)
   export const requireAuth = async (req, res, next) => {
     const token = req.headers.authorization?.split(' ')[1];
     try {
       const payload = jwt.verify(token, process.env.JWT_SECRET);
       req.user = { id: payload.id, role: payload.role };
       next();
     } catch {
       return res.status(401).json({ error: 'Not authenticated' });
     }
   };
   ```
3. **Appliquer le middleware** sur toutes les routes sensibles dans `server/routes.ts`Â :

   ```ts
   router.post('/armies/:id/contracts', requireAuth, requireOwnership('armies', 'id'), async (req, res) => { â€¦ });
   router.post('/trade-rooms', requireAuth, async (req, res) => { â€¦ });
   ```

   Le middleware `requireOwnership` doit comparer `req.user.id` au propriÃ©taire de la ressource (armÃ©e, contrat, etc.).
4. **GÃ©nÃ©rer et retourner un token** lors du login (ex. dans `loginEndpoint`) et mettre Ã  jour le front-end pour inclure ce token dans chaque requÃªte.

## 2. Transactions gÃ©nÃ©ralisÃ©es (nouveau)

### Constat

Certaines opÃ©rations composÃ©es (progression de cartographie, acceptation dâ€™offres, transferts de ressources, etc.) modifient plusieurs tables sans transaction, ce qui peut laisser la base dans un Ã©tat partiellement mis Ã  jour.

### Instructions

1. **Identifier les mÃ©thodes multiâ€‘Ã©critures** (ex. crÃ©ation de cartographie, progression de projet, acceptation dâ€™offres).
2. **Encapsuler chaque ensemble dâ€™Ã©critures** dans une transactionÂ :

   ```ts
   await db.transaction(async (tx) => {
     const project = await tx.update(cartographyProjects)
       .set({ progress: newProgress })
       .where(eq(cartographyProjects.id, projectId))
       .returning();
     if (project.progress >= 1) {
       // crÃ©ation de la carte et autres opÃ©rations
       await tx.insert(mapDocuments).values({...});
       await tx.update(cartographyProjects).set({ status: 'completed' }).where(eq(cartographyProjects.id, projectId));
     }
     // autres mises Ã  jour liÃ©es
   });
   ```
3. **GÃ©rer les exceptions** pour que la transaction soit annulÃ©e si une opÃ©ration Ã©choue.

## 3. Recherche gÃ©ospatiale dans CartographyService (dÃ©jÃ  identifiÃ©)

### Constat

MÃªme si `findRegionAt` filtre maintenant un rectangle avant de calculer la distance, la distance exacte est encore calculÃ©e en mÃ©moire sur ce sous-ensemble.

### Instructions

1. **Ã‰tendre le schÃ©ma**Â : ajouter un champ `point` de type `point` (ou utiliser PostGIS si disponible) dans la table `map_regions`.
2. **CrÃ©er un index gÃ©ospatial** :

   ```sql
   CREATE INDEX map_regions_point_idx ON map_regions USING gist (point);
   ```
3. **Remplacer la requÃªte** par une recherche gÃ©ospatiale :

   ```ts
   const nearbyRegions = await db
     .select()
     .from(mapRegions)
     .where(
       sql`ST_DWithin(point, ST_MakePoint(${x}, ${y})::geography, ${radius})`
     );
   ```

   Si PostGIS nâ€™est pas disponible, rÃ©duire encore la taille du rectangle (`limit`) pour minimiser la boucle en mÃ©moire.

## 4. Filtrage SQL des salles de troc (dÃ©jÃ  identifiÃ©)

### Constat

Certaines mÃ©thodes (ex. `getTradeRoomsForPlayer`) rÃ©cupÃ¨rent toutes les salles et filtrent ensuite en mÃ©moire.

### Instructions

1. **ReprÃ©senter les participants** des salles dans une colonne JSONB `participants` ou crÃ©er une table de jointure `trade_room_participants(room_id, player_id)`.
2. **Ajouter un index GIN** sur `participants` si câ€™est une colonne JSONB :

   ```sql
   CREATE INDEX trade_rooms_participants_idx ON trade_rooms USING gin (participants);
   ```
3. **Modifier la requÃªte** pour filtrer directement en SQL :

   ```ts
   const rooms = await db
     .select()
     .from(tradeRooms)
     .where(sql`${tradeRooms.participants} @> ${JSON.stringify([playerId])}::jsonb`);
   ```

   Avec une table de jointure, effectuer une jointure `INNER JOIN trade_room_participants trp ON trp.room_id = tradeRooms.id` et filtrer sur `trp.player_id = playerId`.

## 5. Validation systÃ©matique et tests (dÃ©jÃ  identifiÃ©)

### Constat

Les payloads des routes ne sont pas tous validÃ©s par Zod et il manque des tests dâ€™intÃ©gration.

### Instructions

1. **DÃ©finir un schÃ©ma Zod** pour chaque type dâ€™entrÃ©e :

   ```ts
   const createArmySchema = z.object({
     name: z.string().min(3),
     ownerId: z.string().uuid(),
     // autres champs...
   });
   ```
2. **CrÃ©er un middleware de validation** :

   ```ts
   const validate = (schema) => (req, res, next) => {
     const result = schema.safeParse(req.body);
     if (!result.success) {
       return res.status(400).json({ error: result.error.flatten() });
     }
     req.body = result.data;
     next();
   };
   ```
3. **Appliquer ce middleware** Ã  toutes les routes POST/PATCH.
4. **Ã‰crire des tests dâ€™intÃ©gration** avec Jest/Vitest et un serveur de test :

   * VÃ©rifier quâ€™une armÃ©e est crÃ©Ã©e correctement.
   * VÃ©rifier quâ€™un contrat est refusÃ© si la compÃ©tence est insuffisante.
   * VÃ©rifier que la progression dâ€™un projet de cartographie et la crÃ©ation de carte sâ€™effectuent avec un rollback en cas dâ€™erreur.
   * VÃ©rifier quâ€™une offre dâ€™Ã©change transfÃ¨re correctement ressources et objets.

## 6. Indexation et performances (nouveau)

### Constat

Bien que des index aient Ã©tÃ© ajoutÃ©s, il faut vÃ©rifier quâ€™ils couvrent toutes les colonnes sur lesquelles on fait des filtres ou jointures.

### Instructions

1. **Analyser les requÃªtes lentes** (avec `EXPLAIN ANALYZE`) pour dÃ©terminer si dâ€™autres index sont nÃ©cessaires (ex. `player_resources.player_id`, `marshal_contracts.army_id` et `status`).
2. **Ajouter des index** pour les colonnes couramment filtrÃ©es :

   ```sql
   CREATE INDEX player_resources_player_id_idx ON player_resources(player_id);
   CREATE INDEX marshal_contracts_army_status_idx ON marshal_contracts(army_id, status);
   ```
3. **RegÃ©nÃ©rer les index** via `server/db/indexes.ts` si ce fichier est conÃ§u pour automatiser leur crÃ©ation.

## 7. ModularitÃ© et documentation (nouveau)

### Constat

La logique mÃ©tier (par ex. construction de requÃªtes) est parfois entremÃªlÃ©e avec le code des routes, et la documentation nâ€™est pas entiÃ¨rement Ã  jour.

### Instructions

1. **CrÃ©er des services ou Â« repositories Â» dÃ©diÃ©s** pour les accÃ¨s DB complexes (par ex. `CampaignRepository.ts` avec `getCampaignsForPlayer(playerId)` qui encapsule la logique JSONB).
2. **Mettre Ã  jour le README**Â : dÃ©crire les nouvelles tables, les endpoints existants, les middlewares dâ€™authentification, les index. PrÃ©ciser comment lancer les migrations et les scripts de seed.
3. **Ajouter des commentaires** au-dessus des fonctions principales pour expliquer les Ã©tapes mÃ©tier (notamment dans `resolveBattleConsequences` et `createExchangeOffer`).

---

### ğŸ”„ SynthÃ¨se

* Les amÃ©liorations dÃ©jÃ  apportÃ©es (filtrage SQL complet, transactions pour les batailles, persistance des Ã©changes) ont rÃ©solu plusieurs problÃ¨mes signalÃ©s.
* Il reste Ã  gÃ©nÃ©raliser lâ€™authentification, Ã  encapsuler les opÃ©rations multiâ€‘Ã©critures dans des transactions, Ã  optimiser certaines recherches encore en mÃ©moire et Ã  systÃ©matiser la validation et les tests.
* En suivant les instructions ciâ€‘dessus, vous consoliderez la phaseâ€¯1 et prÃ©parerez un socle backend robuste pour les Ã©tapes suivantes.
