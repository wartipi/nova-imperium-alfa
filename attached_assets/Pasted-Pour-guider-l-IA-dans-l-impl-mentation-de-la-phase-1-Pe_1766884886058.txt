Pour guider lâ€™IA dans lâ€™implÃ©mentation de la phase 1 â€“ Persistance des donnÃ©es dans ton dÃ©pÃ´t novaâ€‘imperiumâ€‘alfa (branche Niâ€‘architectureâ€‘v9), voici un ensemble dâ€™instructions dÃ©taillÃ©es et directes. Ces Ã©tapes visent Ã  remplacer le stockage en mÃ©moire par une base PostgreSQL via Drizzle, tout en exposant des API propres pour les armÃ©es, les Ã©vÃ©nements publics et la cartographie.

ğŸ¯ Objectif gÃ©nÃ©ral

Passer des structures en mÃ©moire (tableaux et Map) Ã  une base de donnÃ©es persistante et crÃ©er des endpoints API pour manipuler ces donnÃ©es en lecture/Ã©criture.

ğŸ› ï¸ 1. Mise en place de la base de donnÃ©es

Choisir Drizzle et PostgreSQL comme ORM et SGBD (en cohÃ©rence avec le reste du projet).

Ajouter une configuration de connexion (ex. db.ts) dans le dossier server/. Cette configuration doit lire les variables dâ€™environnement (DATABASE_URL, DB_USER, DB_PASSWORD) et exposer une instance Drizzle connectÃ©e Ã  PostgreSQL.

CrÃ©er les tables nÃ©cessaires via des schÃ©mas Drizzle dans shared/schema ou dans un nouveau fichier dÃ©diÃ©. Pour chaque entitÃ©, dÃ©finir les colonnes et les relations :

ArmÃ©es et marÃ©chaux : tables armies, marshal_contracts, campaigns, battle_events (avec colonnes id, ownerId, name, status, createdAt, etc.).

Ã‰vÃ©nements publics : table public_events avec id, type, title, participants, location, priority, timestamp.

Cartographie : tables map_regions, map_documents, cartography_projects (pour remplacer les Map regions, mapDocuments, projects)
raw.githubusercontent.com
.

Relations : utiliser des clÃ©s Ã©trangÃ¨res (armyId, regionId, playerId) et des index sur les colonnes les plus souvent requÃªtÃ©es.

Ã‰crire des migrations : ajouter des scripts (par exemple dans drizzle ou migrations/) pour crÃ©er les tables et les exÃ©cuter au dÃ©marrage du serveur.

ğŸ” 2. Adapter les services

Pour chaque service, remplacer les structures en mÃ©moire par des accÃ¨s Ã  la base via Drizzle.

Service des marÃ©chaux (marshalService.ts)

Remplacer les tableaux armies, contracts, campaigns et battleEvents par des appels ORM. Exemple :

// Avant : stockage en mÃ©moire
private armies: Army[] = [];

// AprÃ¨s : plus de stockage local; utiliser une mÃ©thode Drizzle
async getPlayerArmies(playerId: string): Promise<Army[]> {
  return await db.query.armies.findMany({
    where: { ownerId: playerId }
  });
}


Modifier createArmy, createContract, createCampaign, createBattleEvent pour quâ€™ils effectuent une INSERT en base.

Adapter acceptContract et joinCampaign pour mettre Ã  jour les lignes (UPDATE) correspondantes.

Laisser la logique mÃ©tier (vÃ©rifications de compÃ©tences, unicitÃ© des contrats
raw.githubusercontent.com
, etc.) mais retirer les push sur des tableaux.

Service de cartographie (cartographyService.ts)

Remplacer regions, mapDocuments, projects et subscribers (qui sont des Map) par des tables SQL.

Adapter discoverRegion, startCartographyProject, progressProject pour lire et Ã©crire dans la base.

Service des Ã©vÃ©nements publics

CrÃ©er un PublicEventsService reliÃ© Ã  la table public_events. Les mÃ©thodes doivent lire et Ã©crire les Ã©vÃ©nements via Drizzle.

ğŸŒ 3. Exposer des endpoints API

Ajouter (ou complÃ©ter) des routes REST (ou tRPC) dans server/ pour interfacer le frontâ€‘end avec les services :

ArmÃ©es et marÃ©chaux :

POST /api/armies â†’ crÃ©e une armÃ©e (appel Ã  createArmy).

GET /api/armies/:playerId â†’ liste les armÃ©es dâ€™un joueur (getPlayerArmies).

POST /api/contracts â†’ crÃ©e un contrat de marÃ©chal (appel Ã  createContract).

POST /api/contracts/:id/accept â†’ accepte un contrat (appel Ã  acceptContract).

Ã‰vÃ©nements publics :

GET /api/public-events â†’ liste les Ã©vÃ©nements, avec filtres facultatifs (type, prioritÃ©, participants).

POST /api/public-events â†’ enregistre un nouvel Ã©vÃ©nement public.

Cartographie :

POST /api/cartography/regions â†’ dÃ©couvrir une rÃ©gion (discoverRegion).

POST /api/cartography/projects â†’ dÃ©marrer un projet (startCartographyProject).

PATCH /api/cartography/projects/:id/progress â†’ avancer un projet (progressProject).

Pour chaque endpoint :

Valider les entrÃ©es avec Zod ou une bibliothÃ¨que Ã©quivalente.

Retourner des statuts HTTP appropriÃ©s et des messages clairs (201 pour crÃ©ation, 400 pour erreur de validation, 404 pour entitÃ© inexistante).

ğŸ§ª 4. Migrer et initialiser les donnÃ©es

CrÃ©er un script de seed qui insÃ¨re dans la base des exemples dâ€™armÃ©es, dâ€™Ã©vÃ©nements publics et de rÃ©gions pour le dÃ©veloppement.

Supprimer ou commenter les donnÃ©es de test en mÃ©moire dans le frontâ€‘end et les remplacer par des appels aux API nouvellement crÃ©Ã©es.

âœ”ï¸ 5. Tests et vÃ©rifications

Ã‰crire des tests dâ€™intÃ©gration pour chaque route (ex. crÃ©ation dâ€™une armÃ©e, validation de contrat) afin de vÃ©rifier que les opÃ©rations en base fonctionnent.

ExÃ©cuter les migrations et sâ€™assurer que le serveur dÃ©marre bien avec la base connectÃ©e.