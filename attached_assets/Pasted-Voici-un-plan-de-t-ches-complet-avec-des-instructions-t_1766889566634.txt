Voici un plan de t√¢ches complet, avec des instructions techniques claires, pour corriger les lacunes restantes identifi√©es dans la branche **NI‚Äëarchitecturetest9.0‚Äëagent3**. Ces t√¢ches tiennent compte des am√©liorations d√©j√† apport√©es et se concentrent sur ce qui reste √† corriger.

---

### ‚úÖ Ce qui est d√©j√† r√©solu

* Passage √† PostgreSQL/Drizzle pour la persistance.
* Transactions pour la r√©solution des batailles.
* V√©rification des comp√©tences en base.
* Persistance des √©changes (offres, objets et ressources) et usage de transactions.
* Filtrage SQL des √©v√©nements publics par type, priorit√© et plage de tours.

---

### üõ†Ô∏è T√¢ches √† corriger (avec instructions)

| N¬∞    | Composant                                    | Probl√®me √† corriger                                                                                                                                                              | Instruction technique d√©taill√©e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ----- | -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | PublicEventsService ‚Äì `getEvents`            | Les participants et la localisation sont encore filtr√©s en m√©moire apr√®s la requ√™te SQL.                                                                                         | 1. **Participants**¬†: Stockez `participants` comme un tableau JSONB dans la colonne `participants` de `public_events`. Ajoutez un index GIN sur cette colonne. Modifiez la requ√™te en ajoutant `where(participants @> ARRAY[?]::text[])` pour chaque joueur filtr√©, en utilisant `jsonb_array_elements_text` si n√©cessaire. 2. **Localisation**¬†: Cr√©ez deux colonnes `pos_x` et `pos_y` dans `public_events` (si non pr√©sentes). Ajoutez un index B-tree. Filtrez avec `pos_x BETWEEN x0 - r AND x0 + r` et `pos_y BETWEEN y0 - r AND y0 + r` (x0,y0 = centre, r = rayon). Cela r√©duira le nombre d‚Äô√©v√©nements √† v√©rifier. Calculez ensuite la distance exacte uniquement sur ce sous-ensemble si n√©cessaire. |
| **2** | MarshalService ‚Äì `getPlayerData`             | La r√©cup√©ration des campagnes actives filtre encore en m√©moire les campagnes contenant les arm√©es du joueur.                                                                     | 1. Dans `campaigns`, repr√©sentez `participatingArmies` comme un tableau JSONB ou cr√©ez une table de jointure `campaign_armies( campaign_id, army_id )`. 2. Ajoutez un index GIN ou B-tree sur cette colonne/cl√©. 3. Modifiez la requ√™te `getPlayerData`¬†: s√©lectionnez les campagnes o√π `participatingArmies @> ARRAY[armyId]` (si JSONB) ou effectuez une jointure sur `campaign_armies` avec la liste d‚Äôarm√©es du joueur.                                                                                                                                                                                                                                                                                    |
| **3** | ExchangeService ‚Äì `executeExchange`          | La persistance des ressources est incompl√®te¬†: la m√©thode ne met pas √† jour les soldes des joueurs (seule la table `playerResources` est utilis√©e dans `transferResourcesInTx`). | 1. Cr√©ez une table `player_resources (player_id TEXT, resource_type TEXT, quantity INT, PRIMARY KEY(player_id, resource_type))`. 2. Dans `executeExchange`, lors de l‚Äôacceptation d‚Äôune offre, d√©bitez le vendeur et cr√©ditez l‚Äôacheteur pour chaque type de ressource dans une transaction. Utilisez `UPDATE player_resources SET quantity = quantity + ?` pour chaque joueur, et `INSERT ... ON CONFLICT ...` si la ligne n‚Äôexiste pas. 3. Int√©grez cette mise √† jour dans le m√™me `db.transaction` que pour les objets uniques.                                                                                                                                                                             |
| **4** | G√©n√©ral ‚Äì Transactions                       | Certaines op√©rations qui modifient plusieurs entit√©s ne sont pas transactionnalis√©es (progression de projets de cartographie, acceptation d‚Äôoffres, etc.).                       | Pour chaque m√©thode qui effectue plusieurs √©critures (par ex. progression d‚Äôun projet de cartographie avec r√©compenses multiples, acceptation d‚Äôune offre), entourez les op√©rations de mise √† jour dans `db.transaction(async (tx) => { ‚Ä¶ })`. Si l‚Äôune √©choue, l‚Äôensemble doit √™tre annul√©.                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **5** | ExchangeService ‚Äì `getTradeRoomsForPlayer`   | Filtre encore toutes les salles en m√©moire avant de s√©lectionner celles o√π le joueur est participant.                                                                            | 1. Stockez la liste des participants des salles d‚Äô√©change dans une colonne JSONB `participants`. Ajoutez un index GIN. 2. Modifiez `getTradeRoomsForPlayer` pour faire une requ√™te `select * from trade_rooms where participants @> ARRAY[playerId]`. 3. Supprimez le filtrage en m√©moire apr√®s coup.                                                                                                                                                                                                                                                                                                                                                                                                          |
| **6** | S√©curit√© ‚Äì Authentification et autorisations | Toutes les routes utilisent des identifiants en clair sans authentification.                                                                                                     | 1. Impl√©mentez un syst√®me d‚Äôauthentification (ex. JWT)‚ÄØ: ajoutez un middleware qui v√©rifie le jeton et attache les informations de l‚Äôutilisateur √† `req.user`. 2. Remplacez les identifiants pass√©s en requ√™te par `req.user.id` et v√©rifiez les autorisations (ex. propri√©taire d‚Äôune arm√©e pour cr√©er un contrat). 3. Ajoutez des tests pour s‚Äôassurer qu‚Äôun joueur ne peut pas manipuler les ressources ou les arm√©es d‚Äôun autre.                                                                                                                                                                                                                                                                           |
| **7** | CartographyService ‚Äì `findRegionAt`          | Bien que pr√©filtr√©e, la distance est calcul√©e en m√©moire sur toutes les r√©gions dans le carr√© englobant.                                                                         | 1. Si possible, utilisez un syst√®me de g√©olocalisation SQL (extension `cube`/`earthdistance` ou un champ `POINT`) et un index spatial. 2. Effectuez la recherche en base : `WHERE ST_DWithin(point, ST_MakePoint(x0, y0)::geography, radius)`. 3. Si cela est trop lourd, ajoutez un tri ou un `LIMIT` pour r√©duire le nombre d‚Äô√©l√©ments trait√©s en m√©moire.                                                                                                                                                                                                                                                                                                                                                   |
| **8** | Validation et tests                          | Certaines routes n‚Äôutilisent pas Zod pour valider les entr√©es et il manque des tests d‚Äôint√©gration.                                                                              | 1. Ajoutez un sch√©ma Zod pour chaque type d‚Äôentr√©e POST/PATCH (contrats, cartes, offres, etc.) et utilisez-le dans les routes pour rejeter les requ√™tes invalides. 2. √âcrivez des tests d‚Äôint√©gration (Jest ou Vitest) pour : cr√©er une arm√©e, proposer puis accepter un contrat, cr√©er un projet de cartographie et le faire progresser, publier un √©v√©nement public, √©changer des ressources/objets.                                                                                                                                                                                                                                                                                                         |

---

### üìå Rappel des statuts

* **D√©j√† signal√©** : t√¢ches 1, 5, 6, 7, 8.
* **Nouvelles observations** : t√¢ches 2 et 3 (campagnes & ressources) identifi√©es lors des relectures r√©centes.

Ces instructions devraient permettre √† l‚ÄôIA de corriger efficacement les derniers points bloquants. Apr√®s impl√©mentation, nous pourrons revoir son travail pour valider que la phase¬†1 est enti√®rement achev√©e.
