Parfait. Voici un **prompt d‚Äôinstructions ultra-pr√©cis** √† donner √† ton IA pour corriger les probl√®mes restants dans **`wartipi/nova-imperium-alfa`**, branche **`Ni-architecture-v9`**. Il est organis√© **par fichier**, avec **modifs exactes**, **snippets pr√™ts √† coller** et **crit√®res d‚Äôacceptation**.

---

# ‚úÖ Objectif

Corriger **toutes** les erreurs TypeScript restantes (g√©n√©riques manquants, `Omit` incomplet, types `Map` invalides) et finaliser une v√©rification m√©tier manquante, sans modifier l‚ÄôAPI publique existante.

# üîß Contrainte

* Projet: `wartipi/nova-imperium-alfa`, branche `Ni-architecture-v9`.
* Ne pas refactorer l‚Äôarchitecture, uniquement **corriger/compl√©ter** les types et les guards m√©tier.
* Lint/Build doivent passer: `pnpm run check && pnpm run build`.

---

## 1) Corriger les `Map` et `subscribers` invalides (g√©n√©riques manquants)

### Fichiers concern√©s

* `server/cartographyService.ts`
* `server/exchangeService.ts`
* `server/marketplaceService.ts`
* `server/messageService.ts`
* `server/treatyService.ts`

### Probl√®me

Des d√©clarations de `Map` invalides du style :

```ts
private subscribers: Map void)[]> = new Map();
// ou
private subscribers: Map = new Map();
```

‚Ä¶et d‚Äôautres `Map`/`Set` sans param√®tres : `tradeRooms`, `activeOffers`, `marketItems`, etc.

### Changement √† apporter (mod√®le)

1. Remplacer **toutes** les d√©clarations de `subscribers` par :

```ts
private subscribers: Map<string, Array<(data: any) => void>> = new Map();
```

> Si un service notifie des types plus pr√©cis que `any`, utiliser une union/documenter le type :
> `Map<string, Array<(data: MarketEvent | ExchangeEvent | CartographyEvent) => void>>`. Sinon, rester sur `any` pour ne rien casser.

2. Typage explicite des autres `Map`/`Set` (exemples) :

```ts
private tradeRooms: Map<string, TradeRoom> = new Map();
private activeOffers: Map<string, Offer> = new Map();
private marketItems: Map<string, MarketItem> = new Map();
private uniqueItems: Set<string> = new Set();
```

3. Fonctions utilitaires d‚Äôabonnement (si pr√©sentes) :

```ts
subscribe(key: string, cb: (data: any) => void) {
  const list = this.subscribers.get(key) ?? [];
  list.push(cb);
  this.subscribers.set(key, list);
}

notifySubscribers(key: string, data: any) {
  const list = this.subscribers.get(key);
  if (!list) return;
  for (const cb of list) cb(data);
}
```

### Crit√®res d‚Äôacceptation

* Aucune occurrence r√©siduelle de `Map void)[]>`.
* Aucune `Map`/`Set` sans param√®tres g√©n√©riques.
* `tsc --noEmit` sans erreur.

---

## 2) Compl√©ter les `Omit<‚Ä¶>` incomplets

### Fichiers concern√©s

* `server/messageService.ts` ‚Üí m√©thode `sendMessage`
* `server/treatyService.ts` ‚Üí m√©thode `createTreaty`

### Probl√®me

`Omit` est utilis√© **sans** pr√©ciser les cl√©s √† omettre.

### Changement √† apporter

**`messageService.ts`**

* Supposons l‚Äôinterface :

```ts
interface Message {
  id: string;
  senderId: string;
  recipientId: string;
  content: string;
  timestamp: Date;
  read: boolean;
}
```

* Corriger la signature :

```ts
sendMessage(message: Omit<Message, 'id' | 'timestamp' | 'read'>): Message {
  const newMsg: Message = {
    id: crypto.randomUUID?.() ?? String(Date.now()),
    timestamp: new Date(),
    read: false,
    ...message,
  };
  this.messages.push(newMsg);
  this.notifySubscribers(message.recipientId, newMsg);
  return newMsg;
}
```

**`treatyService.ts`**

* Supposons :

```ts
interface Treaty {
  id: string;
  title: string;
  clauses: string[];
  createdAt: Date;
  status: 'draft' | 'active' | 'void';
  signatures: Array<{ playerId: string; at: Date }>;
  actionPointsCost: number;
}
```

* Corriger la signature :

```ts
createTreaty(treaty: Omit<Treaty, 'id' | 'createdAt' | 'status' | 'signatures' | 'actionPointsCost'>): Treaty {
  const full: Treaty = {
    id: crypto.randomUUID?.() ?? String(Date.now()),
    createdAt: new Date(),
    status: 'draft',
    signatures: [],
    actionPointsCost: this.calculateTreatyCost(treaty),
    ...treaty,
  };
  this.treaties.set(full.id, full);
  this.notifySubscribers(full.id, full);
  return full;
}
```

### Crit√®res d‚Äôacceptation

* `Omit<‚Ä¶>` toujours avec **une liste de cl√©s**.
* Pas d‚Äôerreur `Generic type 'Omit' requires 2 type argument(s)`.

---

## 3) Harmoniser le typage des updates temps r√©el (d√©j√† amorc√©)

### Fichier concern√©

* `server/marshalService.ts`

### √âtat actuel & objectif

* `getSeverityFromUpdateType` existe et convertit `battle_*` ‚Üí `info|warning|critical`.
* **Conserver** ce mapping. V√©rifier que `realTimeUpdate` expose **deux** champs coh√©rents :

```ts
type RealTimeUpdate = {
  type: 'battle_start' | 'phase_change' | 'casualty_report' | 'battle_end';
  severity: 'info' | 'warning' | 'critical';
  payload: any; // ou un type pr√©cis si d√©j√† d√©fini
};
```

* Et que l‚Äô√©metteur WS envoie **les deux** champs (`type` et `severity`).

### Crit√®res d‚Äôacceptation

* Aucun cast forc√© du genre `as 'info'|'warning'|'critical'` sur un `type` de bataille.
* Un seul endroit central pour le mapping (la fonction existante suffit).

---

## 4) V√©rification d‚Äôunicit√© des contrats par arm√©e (d√©j√† ajout√©)

### Fichier concern√©

* `server/marshalService.ts` ‚Üí `createContract`

### √Ä v√©rifier

* Conserver la garde qui interdit un second contrat `proposed|active` pour la m√™me arm√©e.
* Ajouter un test unitaire simple si pr√©sent (sinon, ignorer).

---

## 5) Impl√©menter r√©ellement la v√©rification de comp√©tence

### Fichier concern√©

* `server/marshalService.ts` ‚Üí `checkCompetenceRequirement`

### Contexte

Actuellement, c‚Äôest un **stub**. Il faut brancher la vraie v√©rification.

### Changement √† apporter (mod√®le)

Si tu as d√©j√† un service des comp√©tences (ou une structure en m√©moire), impl√©mente minimalement :

```ts
private playerSkills: Map<string, Map<string, number>> = new Map();
// exemple d‚Äôacc√®s: playerSkills.get(playerId)?.get('treaty_knowledge') ?? 0

checkCompetenceRequirement(playerId: string, competence: string, minLevel: number): boolean {
  const byPlayer = this.playerSkills.get(playerId);
  if (!byPlayer) return false;
  const lvl = byPlayer.get(competence) ?? 0;
  return lvl >= minLevel;
}
```

> Si un vrai service/DB existe, remplacer ce stub par l‚Äôappel r√©el (Drizzle/DAO).

### Crit√®res d‚Äôacceptation

* `createContract` √©choue c√¥t√© service si l‚Äôemployeur n‚Äôa pas `treaty_knowledge >= 1`.
* Validation c√¥t√© route **et** c√¥t√© service (d√©fense en profondeur).

---

## 6) `Record` non typ√© dans `treatyService.ts`

### Probl√®me

`calculateTreatyCost` s‚Äôappuie sur un `Record` sans types explicites.

### Changement √† apporter (exemple)

```ts
type ClauseKey = 'non_aggression' | 'trade_access' | 'defense_pact';
const CLAUSE_COST: Record<ClauseKey, number> = {
  non_aggression: 1,
  trade_access: 2,
  defense_pact: 3,
};

private calculateTreatyCost(treaty: Omit<Treaty, ...>): number {
  // si clauses: string[], mapper vers ClauseKey si possible
  let total = 0;
  for (const c of treaty.clauses) {
    if (c in CLAUSE_COST) total += CLAUSE_COST[c as ClauseKey];
  }
  return total;
}
```

> √Ä d√©faut, utiliser un commentaire `// TODO: typer les clauses` mais garder `Record<string, number>` **explicitement**.

### Crit√®res d‚Äôacceptation

* Plus de `Record` ¬´ nu ¬ª (sans param√®tres).
* `calculateTreatyCost` retourne un `number` sans cast hasardeux.

---

## 7) Nettoyage final & garde-fous

* Rechercher/remplacer r√©siduel :

  * `Map void)[]>` ‚Üí `Map<string, Array<(data: any) => void>>`
  * `private subscribers: Map = new Map();` ‚Üí version typ√©e
* S‚Äôassurer que **toutes** les routes qui cr√©ent/modifient **valident c√¥t√© serveur** (Zod/drizzle-zod si d√©j√† pr√©sent).
* V√©rifier que **tous** les services utilisent des identifiants `string` typ√©s (√©viter `any`).
* Ajouter des `return` types explicites sur les m√©thodes publiques des services.

---

# ‚úÖ Crit√®res de r√©ussite globaux (√† ex√©cuter apr√®s patch)

1. **Type-check**

```bash
pnpm i
pnpm run check
```

‚Üí 0 erreur TS.

2. **Build**

```bash
pnpm run build
```

‚Üí Build OK.

3. **Smoke test rapide**

* Cr√©er un contrat mar√©chal sans la comp√©tence ‚Üí **doit √©chouer** c√¥t√© service.
* Cr√©er un second contrat `proposed` pour la m√™me arm√©e ‚Üí **doit √©chouer**.
* √âmettre un `updateBattle` ‚Üí payload WS contient `type` **et** `severity`.

---

Si tu veux, je peux aussi te fournir un **patch git** unique (diff) regroupant toutes ces corrections pour appliquer en un seul commit.
